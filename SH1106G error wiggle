
void testNormal() {
  int testResults[4][4];
  performConnectivityTest(testResults);
  checkResults(testResults, true);
}

void testWiggle() {
  unsigned long startMillis = millis();
  pass = 1;
  int testResults[4][4];
  int lastSecond = -1; // <-- NUEVO: Para saber qué segundo mostramos por última vez


  display.clearDisplay();
  display.setTextColor(SH110X_BLACK, SH110X_WHITE);
  display.setCursor(6, 0); // Ajusta la posición si es necesario
  display.setTextSize(2);
  display.println(F(" TESTING "));
  display.setTextColor(SH110X_WHITE);
  display.setCursor(10, 17);
  display.setTextSize(3);
  display.println(F("WIGGLE"));
  //display.setCursor(0, 42);
  //display.setTextSize(2);
  //display.println(F("por 10 seg"));
  display.display();

  while (millis() - startMillis < WIGGLE_INTERVAL && pass == 1) {
    performConnectivityTest(testResults);
    pass = checkResults(testResults, false);

    // --- LÓGICA DE LA CUENTA ATRÁS ---
    unsigned long elapsed = millis() - startMillis;
    int secondsRemaining = (WIGGLE_INTERVAL - elapsed) / 1000;

    // Solo actualiza la pantalla si el segundo ha cambiado
    if (secondsRemaining != lastSecond) {
      lastSecond = secondsRemaining; // Actualiza el último segundo mostrado

      // Borra solo el área del número para evitar parpadeos
      display.fillRect(0, 45, SCREEN_WIDTH, 16, SH110X_BLACK); 
      display.setCursor(0, 45);
      display.setTextSize(2);
      display.print(F("Queda "));
      display.print(secondsRemaining); // Muestra los segundos que quedan
      display.print(F("seg"));
      display.display(); // Envía el cambio a la pantalla
    }
  }
  
  checkResults(testResults, true);
}

void performConnectivityTest(int results[4][4]) {
  for (int i = 0; i < 4; i++) {
    digitalWrite(outputs[i], LOW);
    delay(5);
    for (int j = 0; j < 4; j++) {
      results[i][j] = digitalRead(inputs[j]);
    }
    digitalWrite(outputs[i], HIGH);
  }
}

// ===== FUNCIONES DE RESULTADOS =====
int checkResults(int pResults[4][4], bool print) {
  pass = 1;
  const int (*expectedResults)[4] = nullptr;

  switch (cableTypeIndex) {
    case 0: case 1: expectedResults = BALANCED; break;
    case 2: expectedResults = MONO; break;
    case 3: expectedResults = NL2; break;
    case 4: expectedResults = NL4; break;
  }
  
  if (expectedResults != nullptr){
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        if (pResults[i][j] != pgm_read_word(&expectedResults[i][j])) {
          pass = 0;
          break;
        }
      }
  return pass;
}

void showDetailedResults(int pResults[4][4]) {
  display.clearDisplay();
  display.setTextSize(1);
      col_headers = "T   R   S   /";
      row_labels[0] = "T:"; row_labels[1] = "R:"; row_labels[2] = "S:"; row_labels[3] = "/:";
      break;
    case 2: // TS
      col_headers = "T   R   S   /";
7
  delay(500); // Pequeña pausa para no registrar la pulsación inicial
  while (digitalRead(ENCODER_BUTTON_PIN)) {
  // Espera a que el botón se presione (estado LOW)
  }
  while (!digitalRead(ENCODER_BUTTON_PIN)) {
  // Espera a que el botón se suelte (estado HIGH)
 }
}

// ===== FUNCIÓN AUTOTEST =====
void performSelfTest() {
  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(10, 16);
  display.println(F("Auto-Test"));
  display.setTextSize(1);
  
  bool allOK = true;
  
  // 1. Test de salidas
  display.setCursor(0, 32);
  display.print(F("Outputs: "));
  for (int i = 0; i < 4; i++) {
    pinMode(outputs[i], OUTPUT);
    digitalWrite(outputs[i], LOW);
    delay(50);
    int val = digitalRead(outputs[i]);
    digitalWrite(outputs[i], HIGH);
    if (val != LOW) {
      allOK = false;
      display.print("FAIL");
      break;
    }
  }
  if (allOK) display.print("OK");
  
  // 2. Test de entradas
  display.setCursor(0, 42);
  display.print("Inputs: ");
  for (int i = 0; i < 4; i++) {
    pinMode(inputs[i], INPUT_PULLUP);
    delay(50);
    if (digitalRead(inputs[i]) != HIGH) {
      allOK = false;
      display.print("FAIL");
      break;
    }
  }
  if (allOK) display.print("OK");
  
  // 3. Test de controles
  display.setCursor(0, 51);
  display.print("Controls: ");
  if (digitalRead(ENCODER_BUTTON_PIN) != HIGH || digitalRead(WIGGLE_SWITCH) != HIGH) {
    allOK = false;
    display.print("FAIL");
  } else {
    display.print("OK");
  }
  
  // Resultado final
  display.setTextSize(2);
  display.setCursor(40, 0);
  display.println(allOK ? "PASS" : "FAIL");
  display.display();
  
  while (digitalRead(ENCODER_BUTTON_PIN));
  while (!digitalRead(ENCODER_BUTTON_PIN));
}

// ===== FUNCIÓN DE MENÚ =====
void updateMenuDisplay() {
  display.clearDisplay();
  display.setTextSize(3);
  
  switch (cableTypeIndex) {
    case 0: // XLR
      display.setTextSize(4);
      display.setCursor(30, 16);
      display.println(F("XLR"));
      display.setTextSize(2);
      display.setCursor(18, 47);
      display.println(F("Balanced"));
      break;
    case 1: // TRS
      display.setTextSize(4);
      display.setCursor(30, 16);
      display.println(F("TRS"));
      display.setTextSize(2);
      display.setCursor(18, 47);
      display.println(F("Balanced"));
      break;
    case 2: // TS
      display.setTextSize(4);
      display.setCursor(40, 16);
      display.println(F("TS"));
      display.setTextSize(2);
      display.setCursor(5, 47);
      display.println(F("Unbalanced"));
      break;
    case 3: // NL2
      display.setTextSize(3);
      display.setCursor(1, 16);
      display.println(F("Speakon"));
      display.setTextSize(2);
      display.setCursor(45, 47);
      display.println(F("NL2"));
      break;
    case 4: // NL4
      display.setTextSize(3);
      display.setCursor(1, 16);
      display.println(F("Speakon"));
      display.setTextSize(2);
      display.setCursor(45, 47);
      display.println(F("NL4"));
      break;
    case 5: // AUTOTEST
      display.setTextSize(3);
      display.setCursor(26, 17);
      display.println(F("AUTO"));
      display.setCursor(38, 47);
      display.setTextSize(2);
      display.println(F("TEST"));
      break;
  }
  // ===== INICIO DEL CÓDIGO A AÑADIR =====
  // Indicador de modo WIGGLE en la esquina superior derecha
  if (digitalRead(WIGGLE_SWITCH) == LOW) {
    display.setTextSize(2);
    display.setCursor(1, 1); // Ajusta la posición si es necesario
    display.print(F("Mod WIGGLE"));
   } else {
    display.setTextSize(2);
    display.setCursor(1, 1); // Ajusta la posición si es necesario  
    display.print(F("Mod NORMAL"));
  }
  // ===== FIN DEL CÓDIGO A AÑADIR =====

  display.display();  
}
